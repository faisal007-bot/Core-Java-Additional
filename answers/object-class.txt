Without uaing lang package it is impossible to write a java program thats why it is available by default without any import.
Object class contains one additional method register natives but it is not available for child classes hence it is not counted .this method is used by JVM .
TOSTRING
To string method is overridden in all wrapper classes and in string, stringbuffer, stringbuilder class and collection class also.
It is highly recommended to override the tostring method in our classes.
HASHCODE
Hashcode of the object doesn't provide the address of the object in the memory.
For every object a unique number is generated by JVM to uniquely identify that object is known as a hashcode.
Hashcode method uses the address of object in the memory to generate the hashcode.
Tostring method of object class internally uses the hashcode method of object class but if we override the hashcode method then tostring method will use the hashcode method of our class and then it will give the string representation of object.
If we override tostring and hashcode method then it will use these overridden methods of the child class instead of object class.
EQUALS METHOD
Equals method of object class uses == operator for checking equality so it will check the reference of objects.
In equals method this is used for first object on which equals method is called and argument represents second object which is to be compared and we also need to Typecast the object argument to the required class.
1----If we pass object of different class.->
------If we override the equals method then we must handle the class cast exception and inside catch block we must return false.
2-----If we pass null in equals method .->
-------If we override the equals method then we must handle the null pointer exception and inside catch block we must return false.
We can also use different technique to prevent passing different type of object instead of required type by using instanceof operator.
Eg we have student class then
Public boolean equals(object obj)
{
If(this==obj)
Return true;
If(obj instanceof student)
{
Student s = (Student)obj;
If(name.equals(obj.name)&&rollno==s.rollno)
{
Return true;
}
Else
{
Return false;
}
}
Return false;
}
If we want to check the reference if two references pointing to the same object then we must use == at the start of the equals method before performing comparison like in above example.
If we use equals method inside the for string object then it will check the content of the string for comparison but if we use equals method on stringbuffer or stringbuilder object it will check the reference instead of the content bcoz stringbuffer and stringbuilder class doesn't overrdies the equals method of object class.
GETCLASS METHOD
PUBLIC CLASS GETCLASS (){} returns the class object.
Getclass method is used to get the runtime class of the object.
Suppose if we have student class
Syntax Class class = student.getclass();
By using Class object we can get all the details of the corresponding class like declared methods constructors etc..
After loading any class JVM will create Class type object in the heap memory area to get all the information of the class of that object.

If there is no relation between objects no parent or child relation used with == for comparison then it will give compile time error.
If there is no relation between objects used with equals method then it will return false.
If we compare object reference with null either with == operator or woth equals method it will return false.
If 2 objects are equal by equals method then there hashcode must be same.
It is always recommended to override the hashcode method of object class whenever we override the equals method of object class .
In string class hashcode method is already overridden to generate the hashcode based on the content of the string.
It is recommended to use the data members we used inside the equals method also inside the hashcode method to maintain the hashcode and equals method relation.
Equals method is overridden in all wrapper classes, string class and collection classes.and it is always recommended to override the equals method in our classes.
CLONE METHOD
Shallow cloning
If object contains any reference variable of another class then after creating clone method of object class a separate copy pf that object will be created but it doesn't create the dependent object class instead of it will create a reference variable which will point to the reference variable of old object from which we created the clone.
Eg dog and cat class
Dog d1 = new dog(); dog has one primitive value 10 and one reference variable of cat type c . C has primitive value 20.
Dog d2 = (dog)d1.clone();
It will create a clone with primitive value 10 but for reference variable of cat type it wont create new object it will create a reference which will point to the same reference type object cat.
It is known as shallow cloning.
Object class clone method is used for shallow cloning.
For deep cloning we have to override the clone method of object class.
In deep cloning we create the new object of all the class which are connected inside the clone method then we return the object that is expected to be returned and in this case if we do any changes in the cloned object changes won't be reflected in the original object.
This is called as deep cloning.
If the class doesn't contain any referenced variable of another class then it is not recommended to use deep cloning.
If class contains reference object of another class then it is recommended to use deep cloning.
